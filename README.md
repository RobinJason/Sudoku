这是一篇不严谨的readme文档，只是记录在编写代码时的一些思考过程。

# 关于这个项目

数独其实是很常见的游戏，玩法也非常简单。
通过推理得到九个九宫格缺失的每个小框内，对应的正确数字。

一开始只是在掘金上面看到一个gif图片，内容是数独游戏里重新开始时的有趣动画，很想自己来尝试编写一个游戏。
于是就动手了……

## 一些想法

*  初始化游戏时，找到那些正确的九宫格

**困难点**：
   
生成81个格子时，横竖方向的行列，不能有数字重复。
生成一行一行的数字时，可以很容易的做到没有重复，困难的是纵列会有重复。

举个简单的例子： 

    [ 1  2  3 ]     // 横向上面，用某些办法，就可以做到不重复
    [ 2  1  3 ]     // 但是纵向上面，只看第一行与第二行
    [ 3  1  2 ]     // 即使是前两列，通过比较和计算。选择了与第一行不同的数字，第三列也可能会重复

1.  第一种是笨办法
> —— 先不管重复，首先把当前行所有的数字填入数组。完成后这一行后，再与前一行进行比较，有重复，就与其他位置的数字进行交换。直到当前行与上一行对应索引的数字完全不一致。再进行下一行数组的赋值操作。
* 缺点：good luck，耗时会很短。bad luck，耗时，也会浪费浏览器计算资源

2.   第二种是比较繁琐的方法
> —— 思考的过程中，我想起了排列组合。虽然并不是用这个数学方法来彻底的解决问题，但是可以借鉴其中的道理。
>
>排列组合的精髓是：无论这件事情有多少种解决办法，都可以把这个总数计算出来。（当然这是指实际情况，并不是理论情况，理论情况是有无穷大的）
>
再举个例子，还是以前面的123做简化，下面是我列出的，所有的123可能的组合：

    [123] , [132] , [213] , [231] , [312] , [321]    //一共就只有6种排序     

找到所有的组合后，再进行匹配：

    [0]   | 1  2  3 |         | 1  3  2 |   //只有两种模式，在横向和纵向，都没有重复
    [1]   | 2  3  1 |         | 2  1  3 |   //[num]代表行号
    [2]   | 3  1  2 |         | 3  2  1 |

剩下的就是对这两种模式打乱行：

    [0]   | 1  2  3 |         | 1  3  2 |
    [1]   | 2  3  1 |         | 2  1  3 |
    [2]   | 3  1  2 |         | 3  2  1 |

    [0]   | 1  2  3 |         | 1  3  2 |
    [2]   | 3  1  2 |         | 3  2  1 |
    [1]   | 2  3  1 |         | 2  1  3 |

    [1]   [ 2  3  1 ]         | 2  1  3 |
    [0]   [ 1  2  3 ]         | 1  3  2 |
    [2]   [ 3  1  2 ]         | 3  2  1 |

    [1]   [ 2  3  1 ]         | 2  1  3 |
    [2]   [ 3  1  2 ]         | 3  2  1 |
    [0]   [ 1  2  3 ]         | 1  3  2 |

    [2]   [ 3  1  2 ]         | 3  2  1 |
    [0]   [ 1  2  3 ]         | 1  3  2 |
    [1]   [ 2  3  1 ]         | 2  1  3 |

    [2]   [ 3  1  2 ]         | 3  2  1 |
    [1]   [ 2  3  1 ]         | 2  1  3 |
    [0]   [ 1  2  3 ]         | 1  3  2 |

由此就得到所有的九宫格图序，但是很显然，这样也需要大量的计算
* 优点：对于重新开始游戏非常有利，由于初始化时已经得到所有的图序。再次获得新游戏的图例可以直接从存储的数组中随机抽取
* 缺点：计算量很有可能比第一种方法还大，而且要通过代码实现这三个步骤，也并不容易



